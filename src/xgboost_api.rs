#![allow(non_camel_case_types)]
#![allow(dead_code)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
/* automatically generated by rust-bindgen */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type bst_ulong = u64;
#[doc = " \\brief handle to DMatrix"]
pub type DMatrixHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief handle to Booster"]
pub type BoosterHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief handle to a data iterator"]
pub type DataIterHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief handle to a internal data holder."]
pub type DataHolderHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief Mini batch used in XGBoost Data Iteration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XGBoostBatchCSR {
    #[doc = " \\brief number of rows in the minibatch"]
    pub size: usize,
    pub offset: *mut i64,
    #[doc = " \\brief labels of each instance"]
    pub label: *mut f32,
    #[doc = " \\brief weight of each instance, can be NULL"]
    pub weight: *mut f32,
    #[doc = " \\brief feature index"]
    pub index: *mut ::std::os::raw::c_int,
    #[doc = " \\brief feature values"]
    pub value: *mut f32,
}
#[doc = " \\brief Callback to set the data to handle,"]
#[doc = " \\param handle The handle to the callback."]
#[doc = " \\param batch The data content to be set."]
pub type XGBCallbackSetData = ::std::option::Option<
    unsafe extern "C" fn(handle: DataHolderHandle, batch: XGBoostBatchCSR) -> ::std::os::raw::c_int,
>;
#[doc = " \\brief The data reading callback function."]
#[doc = "  The iterator will be able to give subset of batch in the data."]
#[doc = ""]
#[doc = "  If there is data, the function will call set_function to set the data."]
#[doc = ""]
#[doc = " \\param data_handle The handle to the callback."]
#[doc = " \\param set_function The batch returned by the iterator"]
#[doc = " \\param set_function_handle The handle to be passed to set function."]
#[doc = " \\return 0 if we are reaching the end and batch is not returned."]
pub type XGBCallbackDataIterNext = ::std::option::Option<
    unsafe extern "C" fn(
        data_handle: DataIterHandle,
        set_function: XGBCallbackSetData,
        set_function_handle: DataHolderHandle,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\brief get string message of the last error"]
    #[doc = ""]
    #[doc = "  all function in this file will return 0 when success"]
    #[doc = "  and -1 when an error occurred,"]
    #[doc = "  XGBGetLastError can be called to retrieve the error"]
    #[doc = ""]
    #[doc = "  this function is thread safe and can be called by different thread"]
    #[doc = " \\return const char* error information"]
    pub fn XGBGetLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief register callback function for LOG(INFO) messages -- helpful messages"]
    #[doc = "        that are not errors."]
    #[doc = " Note: this function can be called by multiple threads. The callback function"]
    #[doc = "       will run on the thread that registered it"]
    #[doc = " \\return 0 for success, -1 for failure"]
    pub fn XGBRegisterLogCallback(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief load a data matrix"]
    #[doc = " \\param fname the name of the file"]
    #[doc = " \\param silent whether print messages during loading"]
    #[doc = " \\param out a loaded data matrix"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixCreateFromFile(
        fname: *const ::std::os::raw::c_char,
        silent: ::std::os::raw::c_int,
        out: *mut DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a DMatrix from a data iterator."]
    #[doc = " \\param data_handle The handle to the data."]
    #[doc = " \\param callback The callback to get the data."]
    #[doc = " \\param cache_info Additional information about cache file, can be null."]
    #[doc = " \\param out The created DMatrix"]
    #[doc = " \\return 0 when success, -1 when failure happens."]
    pub fn XGDMatrixCreateFromDataIter(
        data_handle: DataIterHandle,
        callback: XGBCallbackDataIterNext,
        cache_info: *const ::std::os::raw::c_char,
        out: *mut DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create a matrix content from CSR format"]
    #[doc = " \\param indptr pointer to row headers"]
    #[doc = " \\param indices findex"]
    #[doc = " \\param data fvalue"]
    #[doc = " \\param nindptr number of rows in the matrix + 1"]
    #[doc = " \\param nelem number of nonzero elements in the matrix"]
    #[doc = " \\param num_col number of columns; when it's set to 0, then guess from data"]
    #[doc = " \\param out created dmatrix"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixCreateFromCSREx(
        indptr: *const usize,
        indices: *const ::std::os::raw::c_uint,
        data: *const f32,
        nindptr: usize,
        nelem: usize,
        num_col: usize,
        out: *mut DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create a matrix content from CSC format"]
    #[doc = " \\param col_ptr pointer to col headers"]
    #[doc = " \\param indices findex"]
    #[doc = " \\param data fvalue"]
    #[doc = " \\param nindptr number of rows in the matrix + 1"]
    #[doc = " \\param nelem number of nonzero elements in the matrix"]
    #[doc = " \\param num_row number of rows; when it's set to 0, then guess from data"]
    #[doc = " \\param out created dmatrix"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixCreateFromCSCEx(
        col_ptr: *const usize,
        indices: *const ::std::os::raw::c_uint,
        data: *const f32,
        nindptr: usize,
        nelem: usize,
        num_row: usize,
        out: *mut DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create matrix content from dense matrix"]
    #[doc = " \\param data pointer to the data space"]
    #[doc = " \\param nrow number of rows"]
    #[doc = " \\param ncol number columns"]
    #[doc = " \\param missing which value to represent missing value"]
    #[doc = " \\param out created dmatrix"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixCreateFromMat(
        data: *const f32,
        nrow: bst_ulong,
        ncol: bst_ulong,
        missing: f32,
        out: *mut DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create matrix content from dense matrix"]
    #[doc = " \\param data pointer to the data space"]
    #[doc = " \\param nrow number of rows"]
    #[doc = " \\param ncol number columns"]
    #[doc = " \\param missing which value to represent missing value"]
    #[doc = " \\param out created dmatrix"]
    #[doc = " \\param nthread number of threads (up to maximum cores available, if <=0 use all cores)"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixCreateFromMat_omp(
        data: *const f32,
        nrow: bst_ulong,
        ncol: bst_ulong,
        missing: f32,
        out: *mut DMatrixHandle,
        nthread: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create matrix content from python data table"]
    #[doc = " \\param data pointer to pointer to column data"]
    #[doc = " \\param feature_stypes pointer to strings"]
    #[doc = " \\param nrow number of rows"]
    #[doc = " \\param ncol number columns"]
    #[doc = " \\param out created dmatrix"]
    #[doc = " \\param nthread number of threads (up to maximum cores available, if <=0 use all cores)"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixCreateFromDT(
        data: *mut *mut ::std::os::raw::c_void,
        feature_stypes: *mut *const ::std::os::raw::c_char,
        nrow: bst_ulong,
        ncol: bst_ulong,
        out: *mut DMatrixHandle,
        nthread: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create a new dmatrix from sliced content of existing matrix"]
    #[doc = " \\param handle instance of data matrix to be sliced"]
    #[doc = " \\param idxset index set"]
    #[doc = " \\param len length of index set"]
    #[doc = " \\param out a sliced new matrix"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixSliceDMatrix(
        handle: DMatrixHandle,
        idxset: *const ::std::os::raw::c_int,
        len: bst_ulong,
        out: *mut DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create a new dmatrix from sliced content of existing matrix"]
    #[doc = " \\param handle instance of data matrix to be sliced"]
    #[doc = " \\param idxset index set"]
    #[doc = " \\param len length of index set"]
    #[doc = " \\param out a sliced new matrix"]
    #[doc = " \\param allow_groups allow slicing of an array with groups"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixSliceDMatrixEx(
        handle: DMatrixHandle,
        idxset: *const ::std::os::raw::c_int,
        len: bst_ulong,
        out: *mut DMatrixHandle,
        allow_groups: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief free space in data matrix"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixFree(handle: DMatrixHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief load a data matrix into binary file"]
    #[doc = " \\param handle a instance of data matrix"]
    #[doc = " \\param fname file name"]
    #[doc = " \\param silent print statistics when saving"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixSaveBinary(
        handle: DMatrixHandle,
        fname: *const ::std::os::raw::c_char,
        silent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief set float vector to a content in info"]
    #[doc = " \\param handle a instance of data matrix"]
    #[doc = " \\param field field name, can be label, weight"]
    #[doc = " \\param array pointer to float vector"]
    #[doc = " \\param len length of array"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixSetFloatInfo(
        handle: DMatrixHandle,
        field: *const ::std::os::raw::c_char,
        array: *const f32,
        len: bst_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief set uint32 vector to a content in info"]
    #[doc = " \\param handle a instance of data matrix"]
    #[doc = " \\param field field name"]
    #[doc = " \\param array pointer to unsigned int vector"]
    #[doc = " \\param len length of array"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixSetUIntInfo(
        handle: DMatrixHandle,
        field: *const ::std::os::raw::c_char,
        array: *const ::std::os::raw::c_uint,
        len: bst_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief set label of the training matrix"]
    #[doc = " \\param handle a instance of data matrix"]
    #[doc = " \\param group pointer to group size"]
    #[doc = " \\param len length of array"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixSetGroup(
        handle: DMatrixHandle,
        group: *const ::std::os::raw::c_uint,
        len: bst_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief get float info vector from matrix"]
    #[doc = " \\param handle a instance of data matrix"]
    #[doc = " \\param field field name"]
    #[doc = " \\param out_len used to set result length"]
    #[doc = " \\param out_dptr pointer to the result"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixGetFloatInfo(
        handle: DMatrixHandle,
        field: *const ::std::os::raw::c_char,
        out_len: *mut bst_ulong,
        out_dptr: *mut *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief get uint32 info vector from matrix"]
    #[doc = " \\param handle a instance of data matrix"]
    #[doc = " \\param field field name"]
    #[doc = " \\param out_len The length of the field."]
    #[doc = " \\param out_dptr pointer to the result"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixGetUIntInfo(
        handle: DMatrixHandle,
        field: *const ::std::os::raw::c_char,
        out_len: *mut bst_ulong,
        out_dptr: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief get number of rows."]
    #[doc = " \\param handle the handle to the DMatrix"]
    #[doc = " \\param out The address to hold number of rows."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixNumRow(handle: DMatrixHandle, out: *mut bst_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief get number of columns"]
    #[doc = " \\param handle the handle to the DMatrix"]
    #[doc = " \\param out The output of number of columns"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGDMatrixNumCol(handle: DMatrixHandle, out: *mut bst_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief create xgboost learner"]
    #[doc = " \\param dmats matrices that are set to be cached"]
    #[doc = " \\param len length of dmats"]
    #[doc = " \\param out handle to the result booster"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterCreate(
        dmats: *const DMatrixHandle,
        len: bst_ulong,
        out: *mut BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief free obj in handle"]
    #[doc = " \\param handle handle to be freed"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterFree(handle: BoosterHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief set parameters"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param name  parameter name"]
    #[doc = " \\param value value of parameter"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterSetParam(
        handle: BoosterHandle,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief update the model in one round using dtrain"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param iter current iteration rounds"]
    #[doc = " \\param dtrain training data"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterUpdateOneIter(
        handle: BoosterHandle,
        iter: ::std::os::raw::c_int,
        dtrain: DMatrixHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief update the model, by directly specify gradient and second order gradient,"]
    #[doc = "        this can be used to replace UpdateOneIter, to support customized loss function"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param dtrain training data"]
    #[doc = " \\param grad gradient statistics"]
    #[doc = " \\param hess second order gradient statistics"]
    #[doc = " \\param len length of grad/hess array"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterBoostOneIter(
        handle: BoosterHandle,
        dtrain: DMatrixHandle,
        grad: *mut f32,
        hess: *mut f32,
        len: bst_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief get evaluation statistics for xgboost"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param iter current iteration rounds"]
    #[doc = " \\param dmats pointers to data to be evaluated"]
    #[doc = " \\param evnames pointers to names of each data"]
    #[doc = " \\param len length of dmats"]
    #[doc = " \\param out_result the string containing evaluation statistics"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterEvalOneIter(
        handle: BoosterHandle,
        iter: ::std::os::raw::c_int,
        dmats: *mut DMatrixHandle,
        evnames: *mut *const ::std::os::raw::c_char,
        len: bst_ulong,
        out_result: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief make prediction based on dmat"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param dmat data matrix"]
    #[doc = " \\param option_mask bit-mask of options taken in prediction, possible values"]
    #[doc = "          0:normal prediction"]
    #[doc = "          1:output margin instead of transformed value"]
    #[doc = "          2:output leaf index of trees instead of leaf value, note leaf index is unique per tree"]
    #[doc = "          4:output feature contributions to individual predictions"]
    #[doc = " \\param ntree_limit limit number of trees used for prediction, this is only valid for boosted trees"]
    #[doc = "    when the parameter is set to 0, we will use all the trees"]
    #[doc = " \\param out_len used to store length of returning result"]
    #[doc = " \\param out_result used to set a pointer to array"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterPredict(
        handle: BoosterHandle,
        dmat: DMatrixHandle,
        option_mask: ::std::os::raw::c_int,
        ntree_limit: ::std::os::raw::c_uint,
        out_len: *mut bst_ulong,
        out_result: *mut *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief load model from existing file"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param fname file name"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterLoadModel(
        handle: BoosterHandle,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief save model into existing file"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param fname file name"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterSaveModel(
        handle: BoosterHandle,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief load model from in memory buffer"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param buf pointer to the buffer"]
    #[doc = " \\param len the length of the buffer"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterLoadModelFromBuffer(
        handle: BoosterHandle,
        buf: *const ::std::os::raw::c_void,
        len: bst_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief save model into binary raw bytes, return header of the array"]
    #[doc = " user must copy the result out, before next xgboost call"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param out_len the argument to hold the output length"]
    #[doc = " \\param out_dptr the argument to hold the output data pointer"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterGetModelRaw(
        handle: BoosterHandle,
        out_len: *mut bst_ulong,
        out_dptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief dump model, return array of strings representing model dump"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param fmap  name to fmap can be empty string"]
    #[doc = " \\param with_stats whether to dump with statistics"]
    #[doc = " \\param out_len length of output array"]
    #[doc = " \\param out_dump_array pointer to hold representing dump of each model"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterDumpModel(
        handle: BoosterHandle,
        fmap: *const ::std::os::raw::c_char,
        with_stats: ::std::os::raw::c_int,
        out_len: *mut bst_ulong,
        out_dump_array: *mut *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief dump model, return array of strings representing model dump"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param fmap  name to fmap can be empty string"]
    #[doc = " \\param with_stats whether to dump with statistics"]
    #[doc = " \\param format the format to dump the model in"]
    #[doc = " \\param out_len length of output array"]
    #[doc = " \\param out_dump_array pointer to hold representing dump of each model"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterDumpModelEx(
        handle: BoosterHandle,
        fmap: *const ::std::os::raw::c_char,
        with_stats: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        out_len: *mut bst_ulong,
        out_dump_array: *mut *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief dump model, return array of strings representing model dump"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param fnum number of features"]
    #[doc = " \\param fname names of features"]
    #[doc = " \\param ftype types of features"]
    #[doc = " \\param with_stats whether to dump with statistics"]
    #[doc = " \\param out_len length of output array"]
    #[doc = " \\param out_models pointer to hold representing dump of each model"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterDumpModelWithFeatures(
        handle: BoosterHandle,
        fnum: ::std::os::raw::c_int,
        fname: *mut *const ::std::os::raw::c_char,
        ftype: *mut *const ::std::os::raw::c_char,
        with_stats: ::std::os::raw::c_int,
        out_len: *mut bst_ulong,
        out_models: *mut *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief dump model, return array of strings representing model dump"]
    #[doc = " \\param handle handle"]
    #[doc = " \\param fnum number of features"]
    #[doc = " \\param fname names of features"]
    #[doc = " \\param ftype types of features"]
    #[doc = " \\param with_stats whether to dump with statistics"]
    #[doc = " \\param format the format to dump the model in"]
    #[doc = " \\param out_len length of output array"]
    #[doc = " \\param out_models pointer to hold representing dump of each model"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterDumpModelExWithFeatures(
        handle: BoosterHandle,
        fnum: ::std::os::raw::c_int,
        fname: *mut *const ::std::os::raw::c_char,
        ftype: *mut *const ::std::os::raw::c_char,
        with_stats: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        out_len: *mut bst_ulong,
        out_models: *mut *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get string attribute from Booster."]
    #[doc = " \\param handle handle"]
    #[doc = " \\param key The key of the attribute."]
    #[doc = " \\param out The result attribute, can be NULL if the attribute do not exist."]
    #[doc = " \\param success Whether the result is contained in out."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterGetAttr(
        handle: BoosterHandle,
        key: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set or delete string attribute."]
    #[doc = ""]
    #[doc = " \\param handle handle"]
    #[doc = " \\param key The key of the attribute."]
    #[doc = " \\param value The value to be saved."]
    #[doc = "              If nullptr, the attribute would be deleted."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterSetAttr(
        handle: BoosterHandle,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the names of all attribute from Booster."]
    #[doc = " \\param handle handle"]
    #[doc = " \\param out_len the argument to hold the output length"]
    #[doc = " \\param out pointer to hold the output attribute stings"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterGetAttrNames(
        handle: BoosterHandle,
        out_len: *mut bst_ulong,
        out: *mut *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize the booster from rabit checkpoint."]
    #[doc = "  This is used in distributed training API."]
    #[doc = " \\param handle handle"]
    #[doc = " \\param version The output version of the model."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterLoadRabitCheckpoint(
        handle: BoosterHandle,
        version: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Save the current checkpoint to rabit."]
    #[doc = " \\param handle handle"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn XGBoosterSaveRabitCheckpoint(handle: BoosterHandle) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
